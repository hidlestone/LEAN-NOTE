二、有意义的命名
2.1、名副其实   
2.2、避免误导   
2.3、做有意义的区分   
productInfo  productData   
nameString  name  table不用出现在表名中  variable不应该出现在变量中   
2.4、使用读得出的名称   
genymdhms  DataRcrd102    
2.5、使用可搜索的名称   
单字母名称和数字常量很难在一片文字中找出来。找MAX_CLASSES__PER很容易。   
单字母名称仅用于短方法中的本地变量。名称长短应与其作用域大小相对应。   
2.6、避免使用带编码   
2.7、避免思维映射   
2.8、类名   
类名和对象名应该使用名称或者名词短语，如customer、WikiPage。类名不应当是动词。   
2.9、方法名   
方法名应当是名词或动词短语。属性访问器、修改器和断言 应该根据其值命名，并依据javeBean标准加上get\set\is前缀。   
2.10、别扮可爱   
2.11、每个概念对应一个词   
2.12、不适用双关语   
add insert append   
2.13、使用解决方案领域名称   
2.14、使用源自所涉及问题领域的名称   
2.15、添加有意义语境   
2.16、不要添加没用的语境   
精确是命名的要点。   
2.17、最后   
取好名字最难的地方在于需要良好的描述技巧和共有文化环境。与其说是一种技术、商业或者管理问题，还不如说是一种教学 问题。   

三、函数  
3.1、短小    
每个函数都只做一件事。  
3.2、只做一件事  
3.3、每个函数一个抽象层级  
确保函数只做一件事，函数中的语句都要在同一抽象层级上。  
3.4、switch语句  
写出短小的switch语句很难。即便是只有两种条件的switch语句也要比我想要写的单个代码块或函数大得多。无法避开switch，不过还是要确保每个switch语句都埋藏在较低的抽象层级，而且永远不重复。当然，我们利用多态实现这一点。   
3.5、使用描述性名称  
3.6、函数参数  
尽量使用少的参数。  
3.6.1、一元参数的普遍形式  
3.6.2、标识参数  使得方法不是只做一件事  
3.6.3、二元参数  
3.6.4、三元函数  
3.6.5、参数对象  
3.6.6、参数列表  
3.6.7、动词和关键字  
3.7、无副作用  
3.8、分隔指令与询问  
函数要么做什么事，要么回答什么问题，但是两个不可得兼。函数应该修改摸个对象状态，或是返回该对象的有关信息，两者都干常会导致混乱。  
3.9、使用异常替代返回错误码  
从指令式函数返回错误码轻微违反了指令与询问分隔的规则，它鼓励了在if语句判断中把指令当作表达式使用。  
3.9.1、抽离try/catch代码块  
3.9.2、错误处理就是一件事  
3.9.3、Erro.java依赖磁铁 枚举类 错误码  
其他很多类抵用到了该类，修改了需要重新编译部署。使用异常代替错误码，新异常就可以冲异常类派生出来，无需重新编译或重新部署。  
3.10、别重复自己  
重复可能是软件中一切罪恶的根源，很多原则和实践规则都是为了控制与消除重复而创建的。  
数据库范式、面向对象基类、AOP、面向组件编程、自从子程序发明依赖，软件开发领域的所有		    
创新都是在不断尝试从源代码中消除重复。  
3.11、结构化编程  
3.12、如何写出这样的函数  
3.13、小结  
大师级程序员把系统当做故事来讲，而不是当做程序来写。  
  
四、注释  
注释的恰当用法是你不我们在代码表达意图时遭遇的失败。  
注释常常会与所描述的代码分隔开封来，截然飘零，越来越不准确。我们应该多花心思，尽量少些注释。  
4.1、注释不能美化糟糕的代码  
带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎复杂的代码像样得多。语与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间情节那堆糟糕的代码。  
4.2、用代码来阐述  
4.3、好注释  想办法不去写注释  
4.3.1、法律信息  
4.3.2、提供信息的注释  
4.3.3、对意图的解释  
4.3.4、阐释  
通常更好的办法是尽量让参数或返回值自身就足够清除。但是如果参数返回值是某个标准库的一部分，或是你不能修改的飞马，帮助阐释其含义的注释就会有用。  
4.3.5、警示  
4.3.6、TODO 注释  
TODO  注释解释了为什么函数的部分实现无所作为，将来应该是怎么样的。  
4.3.7、放大  
注释可以用来放大某种看来不合理之物的重要性。  
4.3.8、公共API中的Javadoc  
编写公共API，就该为它编写良好的Javadoc。  
4.4、坏注释  
4.4.1、喃喃自语  
4.4.2、多余的注释  
4.4.3、误导性注释  
4.4.4、循规式注释  
4.4.5、日志式注释  
4.4.6、废话注释  
4.4.7、可怕的废话  
4.4.8、能用函数或变量时就别用注释  
4.4.9、位置标记  少用标志栏  
4.4.10、括号后面的注释  
4.4.11、归属与署名  这类信息由源码控制系统管理，但还是写下吧。  
4.4.12、注释掉的代码  
4.4.13、HTML注释  
4.4.14、非本地信息  
不在本地注释的上下文环境中给出系统级的信息。  
4.4.15、信息过多  不添加无关信息  
4.4.16、不明显的联系  
4.4.17、函数头  
段函数不需要太多描述，为只做一件事的段函数选个好名字，通常比函头注释要好。  
4.4.19、范例  
  
五、格式  
5.1、格式的目的  
5.2、垂直格式  
短文件通常比长文件容易理解。  
5.2.1、向报纸学习  
源文件 应该像报纸文章。名称应该简单且一目了然，名称本身应该足够告诉我们是否在正确的模块中，源文件的最顶部应该给出高层次的概念和算法。细节往往应该往下渐次展开，知道找到源文件中最底层的函数和细节。  
5.2.2、概念间垂直方向上的区隔  
5.2.3、垂直方向上的靠近  
紧密相关的代码应该互相靠近。  
5.2.4、垂直距离  
除非有良好的理由，否则就不要把关系密切的概念放到不同的文件中。实际上，这也是避免是避免使用protected变量的理由之一。  
5.2.5、垂直顺序  
5.3、横向格式  
5.3.1、水平方向上的区隔和靠近  
5.3.2、水平对齐  
5.3.3、缩进  
5.3.4、空范围 while|for语句体为空，避免大括号省略。  
5.4、团队规则  
一组开发者应该认同采用一种风格。  
5.5、鲍勃大叔的格式规则  
  
六、对象和数据结构  
6.1、数据抽象  
6.2、数据、对象的反对称性  
6.3、德墨忒尔律  
模块不应该了解它所操作对象的内部情形。  
对象隐藏数据暴露操作。  
6.3.1、火车失事  
6.3.2、混杂  
6.3.3、隐藏结构  
6.4、数据传送对象  
最为精炼的数据结构，是一个只有公共不变量没有函数的类，这种数据结构有时被称为数据传送对象DTO。DTO是有用的结构，尤其实在与数据库通信、或解析套接字传递的信息之类的场景中。  
6.5、小结  
对象暴露行为，隐藏数据。  
  
七、错误处理  
7.1、使用异常而非返回码  
7.2、先写try/catch/finally  
7.3、使用不可控异常  
7.4、给出异常发生环境说明  
7.5、调用者需要定义异常类  
7.6、定义常规流程  
7.7、别返回null值  
7.8、别传递null值  
7.9、小结   简洁 强固  
  
八、边界  
8.1、使用第三方代码  
8.2、浏览和边界学习  
8.3、学习log4j  
8.4、学习性测试的好处不只是免费  
8.5、使用尚不存在的代码  
8.6、整洁的边界  
  
九、单元测试  
9.1、TDD三定律  
9.2、保持测试整洁  
9.3、整洁的测试  
9.4、每个测试一个断言  
9.5、FIRST  
  
十、类  
10.1、类组织  
公共静态常量 > 私有静态变量 > 私有实体变量  
10.2、类应该短小  
10.2.1、单一全责原则  
10.2.2、内聚  
类应该只有少量的实体变量。类中的每个方法都用该你操作一个或多个这种变量。  
10.2.3、保持内举行就会得到许多短小的类  
10.3、为了修改而组织  
  
十一、系统  
11.1、如何构建一个城市  
11.2、将系统构造和使用分开  
11.2.1、分解mian  
11.2.2、工厂  
11.2.3、依赖注入  
11.3、扩容  
11.4、Java代理  
11.5、纯Java AOP框架  
11.6、AspectJ的方面  
11.7、测试驱动系统架构  
11.8、优化决策  
11.9、明智使用添加了可论证价值的标准  
11.10、系统需要领域特定语言  
11.11、小结  
  
十二、迭进  
12.1、通过迭进设计达到整洁目的  
12.2、简单设计规则1：运行所有测试  
12.3、简单设计规则2-4：重构  
12.4、不可重复  
12.5、表达力  
12.6、尽量少的类和方法  
  
十三、并发编程  
对象是过程的抽象，线程是调度的抽象。  
13.1、为什么要并发  
并发是一种解耦策略。将做什么和何时做分开。  
13.2、挑战  
13.3、并发防御原则  
13.3.1、单一全责原则  
13.3.2、推论：限制数据作用域  
13.3.3、推论：使用数据复本  
13.3.4、推论：线程应尽可能地独立  
13.4、了解Java库  
13.5、了解执行模型  
13.5.1、生产者-消费者模型  
13.5.2、读者-作者模型  
13.5.3、宴席哲学家  
13.6、警惕同步方法之间的依赖  
13.7、保持同步区域微小  
13.8、很难写正确的关闭代码  
13.9、测试线程代码  
13.9.1、将伪失败看作可能的线程问题  
13.9.2、先 使非线程代码可工作  
13.9.3、编写可插拔的线程代码  
13.9.4、编写可调整的线程代码  
13.9.5、运行多于处理器数量的线程--注意死锁问题  
13.9.6、在不同的平台上运行  
13.9.7、装置试错代码  
13.9.8、硬编码  
13.9.9、自动化  
  
十四、逐步改进  
14.1、Args的实现  
14.2、Args：草稿  
14.2.1、所以我暂停了  
14.2.2、渐进  
14.3、字符串参数  
  
十五、JUnit内幕  
15.1、JUnit框架  
  
十六、重构SerialDate  
16.1、首先让它能工作  
16.2、让它做对  
  
十七、味道和启发    
17.1、注释    
17.2、环境    
17.3、函数    
17.4、一般性问题    
1、一个源文件中存在多种语言    
2、明显的行为未被实现    
3、不正确的边界行为    
4、忽视安全    
5、重复 --尽可能找到并消除重复    
6、在错误的抽象级上的代码    
    我们创建抽象类来容纳较高层级概念，创建派生类来容纳较低层次概念，这样做的时候，需要确保分离完整。    
    所有较低层级概念放在派生类，较高层级概念放在基类中。    
    例如，只与细节实现有关的常量、变量或工具函数不应该出现在基类中。    
7、基类依赖于派生类    
8、信息过多    
    尽量保持接口紧凑。通过限制信息来控制耦合度。    
9、死代码    
10、垂直分割        
11、前后不一致    
12、混淆视听    
13、人为耦合    
14、特性依赖    
15、选择算子参数    
16、晦涩的意图    
17、位置错误权责    
18、不恰当的静态方法    
19、使用解释性变量    
20、函数名应该表达其行为    
21、理解算法    
22、把逻辑依赖改为物理依赖    
23、多态代替if/else 或 switch/case    
24、遵循标准约定    
25、用命名常量代替魔术数    
26、准确    
27、结构甚于约定    
28、封装条件    
29、避免否定性条件    
30、函数只该做一件事    
31、掩藏时序耦合    
32、别随意    
33、封装边界条件    
34、函数应该只在一个抽象层级上    
35、在较高层级放置可配置数据    
36、避免传递浏览    
    
17.5、Java      
1、通过使用通配符避免过长的导入清单      
2、不要继承常量  --使用静态导入      
3、常量VS枚举      
    可以拥有方法和字段，从而成为能比int提供更多表达力和灵活性的有力工具。      
    
17.6、名称      
1、采用描述性名称      
2、名称应与抽象层级相符      
3、尽可能使用标准命名法      
4、无歧义的名称      
5、为较大作用域选用较长名称      
6、避免编码      
7、名称应该说明副作用      
    
17.7、测试      
1、测试恍惚组      
2使用覆盖率工夹具      
3、别略过小测试      
4、被忽略的测试就是对不确定事务的疑问      
5、测试边界条件      
6、全面测试相近的缺陷      
7、测试失败的模式有启发性      
8、测试覆盖率的模式有启发性      
9、测试应该块数      
    
    